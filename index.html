<!doctype html>
<!--suppress HtmlFormInputWithoutLabel -->
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Webpack presentation</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement('link')
      link.rel = 'stylesheet'
      link.type = 'text/css'
      link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css'
      document.getElementsByTagName('head')[0].appendChild(link)
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section data-background="white">
                <img src="https://cdn-images-1.medium.com/max/1200/1*WDicMo0-2NsbcgHXuUtqhg.png" alt="Webpack logo">
            </section>
            <section>
                It's main purpose is to put your .js, .css, .html, .sass files into however many bundles you want
                <img src="./images/bundle.png" alt="bundle">
            </section>
        </section>
        <section>
            <section>
                <h3>At a glance it just allows to:</h3>
                <div class="fragment">
                    <p>not use IIFE:</p>
                    <pre>
                        <code data-trim>
                        (function () {
                            // your code here
                        })();
                        </code>
                    </pre>
                </div>
                <div class="fragment">
                    <img src="https://i.stack.imgur.com/AgFIz.png" alt="Webstorm highlights">
                </div>
            </section>
            <section>
                But actually, it's possibilities are much larger
            </section>
            <section>
                Diving into webpack
                <img src="http://xn--b1aaihe3bya8h.xn--p1acf/media/tinymce/upload/400.jpg" alt="Diving into webpack">
            </section>
            <section data-markdown>
                <textarea cols="30" rows="10" data-template>
                    ### it can
                    1. Convert
                    2. Preprocess
                    3. Bundle
                    4. Minify
                    5. Actually build your code
                </textarea>z
            </section>
            <section>
                So let's dive into webpack
            </section>
        </section>
        <section>
            <section>Webpack config</section>
            <section>
                <h3>It works nice out of the box</h3>
                <p>with zero config</p>
                <img src="https://ingilizcebankasi.com/wp-content/uploads/inside.jpg" alt="works out of box"
                     width="40%">
            </section>
            <section>
                Example webpack config
                <pre><code data-trim>
{
  entry: './src/index.js',
  plugins: [
    new CleanWebpackPlugin(['dist']),
    new HtmlWebpackPlugin({
      title: 'YouTube client by DimaDK24',
    }),
  ],
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist'),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader',
        ],
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: [
          'babel-loader',
        ],
      },
      {
        test: /\.(png|jpg|gif|svg|eot|woff|woff2|ttf)$/,
        use: 'file-loader',
      },
    ],
  },
};
	</code></pre>
            </section>
            <section>
                <h3>Basically it consists of</h3>
                <ol>
                    <li class="fragment">Loaders</li>
                    <li class="fragment">Plugins</li>
                    <li class="fragment">Other minor settings</li>
                </ol>
            </section>
        </section>
        <section>
            <section>Loaders</section>
            <section>
                Convert files or chunks.
                They are implemented as the only function which takes file content and returns it
                as content of CommonJS module
            </section>
            <section>
                Raw loader
                <pre><code data-trim>
                module.exports = function(content) {
                    return "module.exports = " + JSON.stringify(content);
                }
                </code></pre>
            </section>
            <section>
                <h2>Some awesome loaders</h2>
                <ol>
                    <li class="fragment">babel-loader</li>
                    <li class="fragment">css-loader</li>
                    <li class="fragment">style-loader</li>
                    <li class="fragment">file-loader</li>
                    <li class="fragment">img-loader</li>
                    <li class="fragment">autoprefixer-loader</li>
                    <li class="fragment">html-minify-loader</li>
                </ol>
            </section>
        </section>
        <section>
            <section>Plugins</section>
            <section>
                Do whatever they want. They can add hooks to build steps and convert all output, like UglifyJSPlugin
                They can deeply integrate into webpack because they can register hooks within webpacks build system and
                access (and modify) the compiler, and how it works, as well as the compilation. Therefore, they are more
                powerful, but also harder to maintain.
                Plugins work at bundle or chunk level and usually work at the end of the bundle generation process.
                Plugins can also modify how the bundles themselves are created. Plugins have more powerful control than
                loaders.
            </section>
            <section>
                <h2>some awesome plugins</h2>
                <ol>
                    <li class="fragment">HtmlWebpackPlugin</li>
                    <li class="fragment">MiniCssExtractPlugin</li>
                    <li class="fragment">SplitChunksPlugin</li>
                    <li class="fragment">DotenvPlugin</li>
                </ol>
            </section>
        </section>
        <section>Advanced guide for advanced students</section>
        <section>
            <section>code splitting</section>
            <section>
                Basically you can just add few entries
                <pre>
                    <code data-trim>
                        entry: {
                            index: './src/index.js',
                            another: './src/another-module.js'
                        }
                    </code>
                </pre>
            </section>
            <section>SplitChunksPlugin</section>
            <section></section>
        </section>
        <section>
            <section>dev server with live reloading</section>
            <section>
                <img src="https://cdn1.iconfinder.com/data/icons/ilive-by-wwalczyszyn/512/Windows_Live_Mesh.png"
                     alt="live reloading">
            </section>
            <section>
                The best solution for live reloading of dev website when code changes. You just install and run
                webpack-dev-server and it will do it. Charming simple.
            </section>
            <section>But be careful. That stuff is addictive.</section>
        </section>
        <section>
            <section>caching</section>
            <section>
                When you deploy site, it’s important to setup caching to save your content on client systems for faster
                loading next time. But if you add awesome brand new feature or fix annoying bug you want users to pick
                up fresh code immediately. Fortunately webpack helps us a lot in this mission.
            </section>
            <section>
                Typical caching algorithm links cached content with file names. So the easiest way to refresh it —
                change file name. We don’t have to do it manually, webpack will do it for us. We only have to configure
                it in right way. To start we can just add
                <pre>
                    <code data-trim>
                        output: {
                            filename: '[name].[contenthash].js',
                        }
                    </code>
                </pre>
            </section>
            <section>
                But make sure to check webpack docs, if you project consists of a few entry points.
                Cause things got complicated then
            </section>
        </section>
        <section>
            <section>Source maps</section>
            <section>
                <pre>
                    <code data-trim>
                        !function(t){var n={};function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r]
                    </code>
                </pre>
            </section>
            <section>
                <img src="images/after-source-maps.png" alt="Original code" class="stretched">
            </section>
            <section>
                After build, your code entirely changes. It’s probably oneliner with even variable names changed. Cat
                becomes
                a or n. You can’t debug it. There’s were source maps come in. They link generated code with original
                one. So you can watch stack trace like if your code didn’t change at all. This can be harmful in
                production, but nice for development. Also, for production, you should upload source maps to error
                logging service, like Sentry. So your visitors (and potentially hackers) can’t see source maps, but you
                could see stacktraces.
            </section>
            <section>
                <h3>To start just add this line to webpack config</h3>
                <pre>
                    <code data-trim>
                        dev-tool: source-map
                    </code>
                </pre>
            </section>
            <section>
                But be sure to consult docs for production configuration
            </section>
        </section>
        <section>
            <h2>When configured webpack in a right way</h2>
            <img src="https://www.meme-arsenal.com/memes/7c3ae6111b5697646b669c7d137116f2.jpg" alt="meme" width="80%"
                 height="80%">
        </section>
        <section><h2>Thank you very much :)</h2></section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
  // More info about config & dependencies:
  // - https://github.com/hakimel/reveal.js#configuration
  // - https://github.com/hakimel/reveal.js#dependencies
  Reveal.initialize({
    dependencies: [
      {src: 'plugin/markdown/marked.js'},
      {src: 'plugin/markdown/markdown.js'},
      {src: 'plugin/notes/notes.js', async: true},
      {
        src: 'plugin/highlight/highlight.js', async: true, callback: function () {
          hljs.initHighlightingOnLoad()
        }
      }
    ]
  })
</script>
</body>
</html>
